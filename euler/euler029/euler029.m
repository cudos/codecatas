#! /usr/bin/octave -qf
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Consider all integer combinations of ab for 2 ≤ a ≤ 5 and
# 2 ≤ b ≤ 5:
#
#     22=4, 23=8, 24=16, 25=32
#     32=9, 33=27, 34=81, 35=243
#     42=16, 43=64, 44=256, 45=1024
#     52=25, 53=125, 54=625, 55=3125
#
# If they are then placed in numerical order, with any
# repeats removed, we get the following sequence of 15
# distinct terms:
#
# 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024,
# 3125
#
# How many distinct terms are in the sequence generated by
# ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

MAX = 100;
dups = 0;
format long;

dups = [];

# for a2 = 2:MAX
#     printf(".");
#     for b2 = 2:MAX-1
#         for b1 = b2+1:MAX
#             a1 = power(a2, b2/b1);
#             if (2 <= a1 && a1 <= MAX && a1 - floor(a1) == 0)
#                 if (a2 == power(a1, b1/b2))
#                     dups += 1;
#                 endif
#             endif
#
#             # if (a1 - floor(a1) == 0)
#             #     dups += 1;
#             #     # if (2 <= a1 && a1 <= MAX)
#             #     #     dups += 1;
#             #     #     printf("(%d,%d,%d,%d)", a1, b1, a2, b2);
#             #     # endif
#             # endif
#         endfor
#     endfor
# endfor
#
# # for b1 = 2:MAX
# #     printf(".");
# #     for a1 = 2:MAX
# #         for a2 = a1+1:MAX
# #             b2 = b1 * (log(a1) / log(a2));
# #             if (b2 < b1 && b2 >= 2 && b2 <= MAX)  # && (b2 - floor(b2)) == 0)
# #                 if (power(a1, b1) == power(a2, b2))
# #                     dups += 1;
# #                     printf("(%d,%d,%d,%d)", a1, b1, a2, b2);
# #                 endif
# #             endif
# #         endfor
# #     endfor
# # endfor

disp((MAX - 1) * (MAX - 1) - dups);
